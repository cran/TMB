#ifndef HAVE_EIGEN_NUMTRAITS_HPP
#define HAVE_EIGEN_NUMTRAITS_HPP
// Autogenerated - do not edit by hand !
#define GLOBAL_HASH_TYPE unsigned int
#define GLOBAL_COMPRESS_TOL 16
#define GLOBAL_UNION_OR_STRUCT union
#define stringify(s) #s
#define xstringify(s) stringify(s)
#define THREAD_NUM 0
#define GLOBAL_INDEX_VECTOR std::vector<GLOBAL_INDEX_TYPE>
#define GLOBAL_INDEX_TYPE unsigned int
#define CONSTEXPR constexpr
#define ASSERT2(x, msg)                          \
  if (!(x)) {                                    \
    Rcerr << "ASSERTION FAILED: " << #x << "\n"; \
    Rcerr << "POSSIBLE REASON: " << msg << "\n"; \
    abort();                                     \
  }
#define GLOBAL_MAX_NUM_THREADS 48
#define INDEX_OVERFLOW(x) \
  ((size_t)(x) >= (size_t)std::numeric_limits<GLOBAL_INDEX_TYPE>::max())
#define ASSERT(x)                                \
  if (!(x)) {                                    \
    Rcerr << "ASSERTION FAILED: " << #x << "\n"; \
    abort();                                     \
  }
#define GLOBAL_REPLAY_TYPE ad_aug
#define GLOBAL_MIN_PERIOD_REP 10
#define INHERIT_CTOR(A, B)                                       \
  A() {}                                                         \
  template <class T1>                                            \
  A(const T1 &x1) : B(x1) {}                                     \
  template <class T1, class T2>                                  \
  A(const T1 &x1, const T2 &x2) : B(x1, x2) {}                   \
  template <class T1, class T2, class T3>                        \
  A(const T1 &x1, const T2 &x2, const T3 &x3) : B(x1, x2, x3) {} \
  template <class T1, class T2, class T3, class T4>              \
  A(const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4)      \
      : B(x1, x2, x3, x4) {}
#define GLOBAL_SCALAR_TYPE double
#include <Eigen/Core>
#include "global.hpp"

namespace Eigen {

template <>
struct NumTraits<TMBad::ad_aug> : NumTraits<TMBad::Scalar> {
  typedef TMBad::ad_aug Real;
  typedef TMBad::ad_aug NonInteger;
  typedef TMBad::ad_aug Nested;
};

template <>
struct NumTraits<TMBad::ad_adapt> : NumTraits<TMBad::Scalar> {
  typedef TMBad::ad_adapt Real;
  typedef TMBad::ad_adapt NonInteger;
  typedef TMBad::ad_adapt Nested;
};

template <typename BinOp>
struct ScalarBinaryOpTraits<TMBad::ad_aug, TMBad::Scalar, BinOp> {
  typedef TMBad::ad_aug ReturnType;
};
template <typename BinOp>
struct ScalarBinaryOpTraits<TMBad::Scalar, TMBad::ad_aug, BinOp> {
  typedef TMBad::ad_aug ReturnType;
};

}  // namespace Eigen
#endif  // HAVE_EIGEN_NUMTRAITS_HPP
